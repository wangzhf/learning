
## 概念

### 同步和异步
同步和异步关注的是调用者的行为方式，即是否主动等待结果的返回。
当程序发生一个调用时，调用者主动等待结果返回，即为同步；
当程序发生一个调用时，调用者不等待结果返回（不会立即返回结果），而是继续执行其他操作，当被调用者操作完成后，通过某种形式（状态、消息通知或回调）来通知调用者结果，即为异步。

### 阻塞和非阻塞
阻塞和非阻塞关注的是调用者在等待返回调用结果之前的状态。
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

> 同步阻塞：调用者发出某调用之后，如果函数不能立即返回，则挂起所在线程，等待结果，直到结果返回；

> 同步非阻塞：调用者发出调用之后，如果当时有数据可读，则读取并返回，如果没有数据可读，则线程继续向下执行。在实际使用时，read调用会在一个循环中，这样就可以不断的读取数据（尽管可能某次read操作并不能获得任何数据）；

> 异步阻塞：调用者发出调用之后，线程挂起，当被调用者操作完成后通过某种机制来通知调用者（在调用者获得结果之前，调用者所在线程一直阻塞，这个看起来和同步阻塞很像，但可以这样理解，同步阻塞相当于调用者A调用了一个函数F，F是在调用者A所在的线程中完成的，而异步阻塞相当于调用者A发出对F的调用，然后A所在线程挂起，而实际F是在另一个线程中完成，然后另一个线程通知给A所在的线程，更准确的是将两个线程分别换成用户进程和内核）；

> 异步非阻塞：调用者发出调用之后，线程继续执行其他的操作，当被调用者操作完成后通过某种机制（状态、消息通知或回调）来通知调用者。


### BIO
BIO(Blocking-IO), 同步阻塞IO。采用BIO通信模型的服务器，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。
该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端访问数呈1:1的正比关系，由于线程是Java虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。
参见源码：`src/main/java/com/wangzhf/bio`

### 伪异步IO
为了解决同步阻塞IO面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化，后端通过一个线程池来处理多个客户端的请求接入，形成`客户端个数M：线程池最大线程数N`的比例关系，其中M可以远远大于N，通过线程池可以灵活的调配线程资源，设置线程最大值，防止由于海量并发接入导致线程耗尽。
原理：当有新的客户端接入的时候，将客户端的Socket封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，他的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。
弊端：伪异步IO跟BIO一样，仍然是同步阻塞的（InputStream.read()和OutputStream.write()阻塞），假如请求的read或write耗时较长的话，会导致其他请求等待时间过长或超时。
参见源码：`src/main/java/com/wangzhf/pseudo_io`

### NIO
NIO(New IO 或 Non-block IO)，非阻塞，是同步IO（IO多路复用）。NIO在JDK1.4中引入，弥补了原来同步阻塞IO的不足。下面对NIO的一些概念和功能做下简单介绍。

1. 缓冲区Buffer
在NIO库中，所有数据都是用缓冲区处理的，在读取数据时，他是直接读到缓冲区中；在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
缓冲区实质上是一个数组。通常他是一个字节数组（ByteBuffer）每一种Java基本类型（除了Boolean类型）都对应一种缓冲区，如：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。除了ByteBuffer，每一个Buffer类都有完全一样的操作，只是他们处理的数据不一样。因为大多数标准IO操作都是用ByteBuffer，所以他除了具有一般缓冲区的操作之外，还提供一些特有的操作，方便网络读写。

2. 通道Channel
Channel是一个通道，可以通过他读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处是通道是双向的，流只是在一个方向上移动，而且通道可以用于读、写或通知用于读写。

3. 多路复用器Selector
多路复用器提供选择已经就绪的任务的能力。简单来说，Selector会不断的轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续IO操作。


### AIO
AIO(Asynchronous IO)，异步非阻塞IO，异步通道提供两种方式获取操作结果：
- 通过java.util.Future类来表示异步操作的结果
- 在执行异步操作的时候传入一个java.nio.channels.CompletionHandler接口的实现类作为操作完成的回调。


### 几种IO对比

<table>
    <tr>
        <td></td>
        <td>同步阻塞IO（BIO）</td>
        <td>伪异步IO</td>
        <td>非阻塞IO（NIO）</td>
        <td>异步IO（AIO）</td>
    </tr>
    <tr>
        <td>客户端个数：IO线程</td>
        <td>1:1</td>
        <td>M:N（其中M可以大于N）</td>
        <td>M:1（1个IO线程处理多个客户端连接）</td>
        <td>M:0（不需要启动额外的IO线程，被动回调）</td>
    </tr>
    <tr>
        <td>IO类型（阻塞）</td>
        <td>阻塞IO</td>
        <td>阻塞IO</td>
        <td>非阻塞IO</td>
        <td>非阻塞IO</td>
    </tr>
    <tr>
        <td>IO类型（同步）</td>
        <td>同步IO</td>
        <td>同步IO</td>
        <td>同步IO（IO多路复用）</td>
        <td>异步IO</td>
    </tr>
    <tr>
        <td>API使用难度</td>
        <td>简单</td>
        <td>简单</td>
        <td>非常复杂</td>
        <td>复杂</td>
    </tr>
    <tr>
        <td>调试难度</td>
        <td>简单</td>
        <td>简单</td>
        <td>复杂</td>
        <td>复杂</td>
    </tr>
    <tr>
        <td>可靠性</td>
        <td>非常差</td>
        <td>差</td>
        <td>高</td>
        <td>高</td>
    </tr>
    <tr>
        <td>吞吐量</td>
        <td>低</td>
        <td>中</td>
        <td>高</td>
        <td>高</td>
    </tr>    
    
</table>
